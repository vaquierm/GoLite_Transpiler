
open OUnit2
open Exceptions
open Ast
open Weeding
open Typecheck
open Emit

let bubble_sort _ =
  let ast = Ast_build.build_ast "test/test_programs/emit/bubblesort.go" in
  let weeded_ast = weed_program ast in
  typecheck_program weeded_ast;
  let cpp_str = program_emit weeded_ast in
    assert_equal cpp_str "#include <iostream>\n#include <vector>\n#include <cstdlib>\ntemplate<class T> class Slice {\npublic:\n    Slice() {\n        end = 0;\n    }\n    ~Slice() {\n        if (new_itms != nullptr) {\n            delete[] new_itms;\n        }\n    }\n\n    Slice* slice(int start, int end) {\n        return new Slice(this, start, end);\n    }\n    Slice* slice(int start, int end, int max) {\n        return new Slice(this, start, end, max);\n    }\n    Slice* append(T val) {\n        return new Slice(val, this);\n    }\n    T& operator[] (int x) {\n        if (x < 0 || x > len()) {\n            std::cerr << \"Index \" << x << \" out of bounds\" << std::endl;\n            exit(0);\n        }\n        return *(this->v[x]);\n    }\n    int len() {\n        return end;\n    }\n    int cap() {\n        return this->v.size();\n    }\nprivate:\n    T* new_itms = nullptr;\n    int end;\n    std::vector<T*> v;\n    void copy_vec(std::vector<T*> v, int start, int n) {\n        for (int i = start; i < n+start; i++) {\n            this->v.push_back(v[i]);\n        }\n    }\n    Slice(T new_val, Slice *old) {\n        copy_vec(old->v, 0, old->cap());\n        this->end = old->end + 1;\n        if (old->cap() == 0) {\n            this->new_itms = new T[2];\n            this->new_itms[0] = new_val;\n            this->new_itms[1] = new_val;\n            this->v.push_back(&(this->new_itms[0]));\n            this->v.push_back(&(this->new_itms[1])); // Should be default val\n        }\n        else if (old->end == old->cap()) {\n            this->new_itms = new T[old->cap()];\n            for (int i = old->end; i < old->cap() * 2; i++) {\n                this->new_itms[i - old->end] = new_val;\n                this->v.push_back(&(this->new_itms[i - old->end])); // Should be default val\n            }\n        }\n        else {\n            *(this->v[old->end]) = new_val;\n        }\n\n    }\n    Slice(Slice *old, int start, int end) {\n        copy_vec(old->v, start, old->cap() - start);\n        if (start < 0) {\n            std::cerr << \"Start index must be greater than 0\" << std::endl;\n            exit(0);\n        }\n        if (end > old->cap()) {\n            std::cerr << \"End index must be less than the capacity\" << std::endl;\n            exit(0);\n        }\n        this->end = end - start;\n    }\n    Slice(Slice *old, int start, int end, int max) {\n        copy_vec(old->v, start, max - start);\n        if (start < 0 || end < 0 || max < 0) {\n            std::cerr << \"All indices must be greater than 0\" << std::endl;\n            exit(0);\n        }\n        if (end > old->cap()) {\n            std::cerr << \"End index must be less than the capacity\" << std::endl;\n            exit(0);\n        }\n        this->end = end - start;\n        if (max < end) {\n            std::cerr << \"The max index must be greater or equal to the end\" << std::endl;\n            exit(0);\n        }\n        if (max > old->cap()) {\n            std::cerr << \"The new capacity cannot be larger than the old capacity\" << std::endl;\n            exit(0);\n        }\n    }\n};\ntemplate <class T>\nconstexpr int len(Slice<T> &slice) {\n    slice.len();\n}\nvoid bubblesort(Slice<int> &items);\nint main();\nvoid bubblesort(Slice<int> &items) {\n    bool sorted = false;\n    int n = len(items);\n    while ((!sorted)) {\n        bool swapped = false;\n        {\n            int i = 0;\n            for (; (i < (n - 1)); i = (i + 1)){\n                if ((items[i] > items[(i + 1)])) {\n                    items[(i + 1)] = (items[i] ^ items[(i + 1)]);\n                    items[i] = (items[i] ^ items[(i + 1)]);\n                    items[(i + 1)] = (items[i] ^ items[(i + 1)]);\n                    swapped = true;\n                }\n            }\n        }\n        if ((!swapped)) {\n            sorted = true;\n        }\n        n = (n - 1);\n    }\n}\nint main() {\n    Slice<int> glist;\n    glist = *glist.append(2);\n    glist = *glist.append(6);\n    glist = *glist.append(9);\n    glist = *glist.append(24);\n    glist = *glist.append(26);\n    glist = *glist.append(65);\n    glist = *glist.append(20);\n    glist = *glist.append(87);\n    glist = *glist.append(6);\n    glist = *glist.append(8);\n    glist = *glist.append(35);\n    bubblesort(glist);\n    {\n        int i = 0;\n        for (; (i < len(glist)); i = (i + 1)){\n            std::cout << glist[i] << std::endl;\n        }\n    }\n}\n"
;;

let binary_search _ =
  let ast = Ast_build.build_ast "test/test_programs/emit/binary_search.go" in
  let weeded_ast = weed_program ast in
  typecheck_program weeded_ast;
  let cpp_str = program_emit weeded_ast in
    assert_equal cpp_str "#include <array>\n#include <iostream>\nint bin_search(std::array<int, 10> &array, int start, int end, int target);\nint main();\nint bin_search(std::array<int, 10> &array, int start, int end, int target) {\n    if ((start > end)) {\n        return (-1);\n    }\n    int mid = ((end + start) / 2);\n    if ((array[mid] == target)) {\n        return mid;\n    }\n    else {\n        if ((array[mid] > target)) {\n            return bin_search(array, start, (mid - 1), target);\n        }\n        else {\n            return bin_search(array, (mid + 1), end, target);\n        }\n    }\n}\nint main() {\n    std::array<int, 10> glist;\n    glist[0] = 0;\n    glist[1] = 3;\n    glist[2] = 3;\n    glist[3] = 8;\n    glist[4] = 9;\n    glist[5] = 10;\n    glist[6] = 13;\n    glist[7] = 14;\n    glist[8] = 18;\n    glist[9] = 19;\n    std::cout << bin_search(glist, 0, 9, 13) << std::endl;\n}\n"
;;

let fibonacci _ =
  let ast = Ast_build.build_ast "test/test_programs/emit/fibonacci.go" in
  let weeded_ast = weed_program ast in
  typecheck_program weeded_ast;
  let cpp_str = program_emit weeded_ast in
    assert_equal cpp_str "#include <array>\n#include <iostream>\ntemplate <class T, std::size_t N>\nconstexpr int len(const std::array<T, N>) noexcept\n{\n    return (int) N;\n}\nint fib(int n);\nint main();\nint fib(int n) {\n    if ((n < 2)) {\n        return ((int) 1);\n    }\n    return (fib((n - 1)) + fib((n - 2)));\n}\nint main() {\n    std::array<int, 10> fib_nums;\n    {\n        int i = 0;\n        for (; (i < len(fib_nums)); i = (i + 1)){\n            fib_nums[i] = fib(i);\n        }\n    }\n    {\n        int i = 0;\n        for (; (i < len(fib_nums)); i = (i + 1)){\n            std::cout << fib_nums[i] << std::endl;\n        }\n    }\n}\n"
;;

let students_gpa _ =
  let ast = Ast_build.build_ast "test/test_programs/emit/students_gpa.go" in
  let weeded_ast = weed_program ast in
  typecheck_program weeded_ast;
  let cpp_str = program_emit weeded_ast in
    assert_equal cpp_str "#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\ntemplate<class T> class Slice {\npublic:\n    Slice() {\n        end = 0;\n    }\n    ~Slice() {\n        if (new_itms != nullptr) {\n            delete[] new_itms;\n        }\n    }\n\n    Slice* slice(int start, int end) {\n        return new Slice(this, start, end);\n    }\n    Slice* slice(int start, int end, int max) {\n        return new Slice(this, start, end, max);\n    }\n    Slice* append(T val) {\n        return new Slice(val, this);\n    }\n    T& operator[] (int x) {\n        if (x < 0 || x > len()) {\n            std::cerr << \"Index \" << x << \" out of bounds\" << std::endl;\n            exit(0);\n        }\n        return *(this->v[x]);\n    }\n    int len() {\n        return end;\n    }\n    int cap() {\n        return this->v.size();\n    }\nprivate:\n    T* new_itms = nullptr;\n    int end;\n    std::vector<T*> v;\n    void copy_vec(std::vector<T*> v, int start, int n) {\n        for (int i = start; i < n+start; i++) {\n            this->v.push_back(v[i]);\n        }\n    }\n    Slice(T new_val, Slice *old) {\n        copy_vec(old->v, 0, old->cap());\n        this->end = old->end + 1;\n        if (old->cap() == 0) {\n            this->new_itms = new T[2];\n            this->new_itms[0] = new_val;\n            this->new_itms[1] = new_val;\n            this->v.push_back(&(this->new_itms[0]));\n            this->v.push_back(&(this->new_itms[1])); // Should be default val\n        }\n        else if (old->end == old->cap()) {\n            this->new_itms = new T[old->cap()];\n            for (int i = old->end; i < old->cap() * 2; i++) {\n                this->new_itms[i - old->end] = new_val;\n                this->v.push_back(&(this->new_itms[i - old->end])); // Should be default val\n            }\n        }\n        else {\n            *(this->v[old->end]) = new_val;\n        }\n\n    }\n    Slice(Slice *old, int start, int end) {\n        copy_vec(old->v, start, old->cap() - start);\n        if (start < 0) {\n            std::cerr << \"Start index must be greater than 0\" << std::endl;\n            exit(0);\n        }\n        if (end > old->cap()) {\n            std::cerr << \"End index must be less than the capacity\" << std::endl;\n            exit(0);\n        }\n        this->end = end - start;\n    }\n    Slice(Slice *old, int start, int end, int max) {\n        copy_vec(old->v, start, max - start);\n        if (start < 0 || end < 0 || max < 0) {\n            std::cerr << \"All indices must be greater than 0\" << std::endl;\n            exit(0);\n        }\n        if (end > old->cap()) {\n            std::cerr << \"End index must be less than the capacity\" << std::endl;\n            exit(0);\n        }\n        this->end = end - start;\n        if (max < end) {\n            std::cerr << \"The max index must be greater or equal to the end\" << std::endl;\n            exit(0);\n        }\n        if (max > old->cap()) {\n            std::cerr << \"The new capacity cannot be larger than the old capacity\" << std::endl;\n            exit(0);\n        }\n    }\n};\nstruct student {\n    std::string name;\n    float gpa;\n    Slice<struct struct_89809344> courses;\n} student;\nstruct struct_89809344 {\n    std::string course_code;\n    char grade;\n} struct_89809344;\ntemplate <class T>\nconstexpr int len(Slice<T> &slice) {\n    slice.len();\n}\nbool course_exists(struct student &s, std::string course_code);\nvoid add_course(struct student &s, std::string course_code, char grade);\nfloat grade_to_points(char grade);\nvoid update_gpa(struct student &s);\nvoid print_gpa(struct student &s);\nint main();\nbool course_exists(struct student &s, std::string course_code) {\n    {\n        int i = 0;\n        for (; (i < len(s.courses)); i = (i + 1)){\n            if ((s.courses[i].course_code == course_code)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nvoid add_course(struct student &s, std::string course_code, char grade) {\n    if (course_exists(s, course_code)) {\n        std::cout << ((((\"Could not add course \" + course_code) + \" because student \") + s.name) + \" is has already taken it\") << std::endl;\n        return;\n    }\n    struct struct_89809344 new_course;\n    new_course.course_code = course_code;\n    new_course.grade = grade;\n    s.courses = *s.courses.append(new_course);\n    update_gpa(s);\n}\nfloat grade_to_points(char grade) {\n    if ((grade == 'A')) {\n        return 4.;\n    }\n    else {\n        if ((grade == 'B')) {\n            return 3.;\n        }\n        else {\n            if ((grade == 'C')) {\n                return 2.;\n            }\n            else {\n                if ((grade == 'D')) {\n                    return 1.;\n                }\n                else {\n                    if ((grade == 'F')) {\n                        return 0.;\n                    }\n                }\n            }\n        }\n    }\n    std::cout << \"Unknown grade: \";\n    std::cout << grade;\n    std::cout << \", treating as fail\" << std::endl;\n    return 0.;\n}\nvoid update_gpa(struct student &s) {\n    if ((len(s.courses) == 0)) {\n        return;\n    }\n    float points = 0.;\n    {\n        int i = 0;\n        for (; (i < len(s.courses)); i = (i + 1)){\n            points = (points + grade_to_points(s.courses[i].grade));\n        }\n    }\n    s.gpa = (points / ((float) len(s.courses)));\n}\nvoid print_gpa(struct student &s) {\n    std::cout << ((\"The student \" + s.name) + \" has GPA: \");\n    std::cout << s.gpa << std::endl;\n}\nint main() {\n    struct student m;\n    m.name = \"Micheal\";\n    std::cout << ((\"Student \" + m.name) + \" got an A in ECSE200\") << std::endl;\n    add_course(m, \"ECSE200\", 'A');\n    print_gpa(m);\n    std::cout << ((\"Student \" + m.name) + \" got a B in ECSE210\") << std::endl;\n    add_course(m, \"ECSE210\", 'B');\n    print_gpa(m);\n    std::cout << ((\"Student \" + m.name) + \" got an A in ECSE251\") << std::endl;\n    add_course(m, \"ECSE251\", 'A');\n    print_gpa(m);\n}\n"
;;
